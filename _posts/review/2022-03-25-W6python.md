---
title:  'W06 Python 기초'
categories: 'review'
---

# 파이썬  기초
# Print 사용법
# 참조 : https://www.python-course.eu/python3_formatted_output.php

"""
참고 : Escape 코드

\n : 개행
\t : 탭
\\ : 문자
\' : 문자
\" : 문자
\000 : 널 문자
...

"""
# 기본 출력
print('Python Start!') 
print("Python Start!") 
print("""Python Start!""")
print('''Python Start!''')

print()

# separator 옵션 사용
print('P', 'Y', 'T', 'H','O','N', sep='')
print('010', '7777', '7777', sep='-')
print('python', 'google.com', sep='@')

print()

# end 옵션 사용
print('Welcome To', end=' ')
print('IT News', end=' ')
print('Web Site')

print()

# file 옵션 사용
import sys

print('Learn Python', file=sys.stdout)

print()

# format 사용(d, s, f)  정수, 문자, 실수
print('%s %s' % ('one', 'two'))     <--- 가독성이  좋다.   입력하는 타입을 선언해주기 때문에
print('{} {}'.format('one', 'two'))     <-- 좀더 유연하다   format 함수가 처리 해줌
print('{1} {0}'.format('one', 'two'))   <---  format 받아드리는 인덱싱이 0 부터 시작 한다   순서를 지정해서 출력

# %s
print('%10s' % ('nice'))         # <--- 여기서 10은 10개의 자리수를 의미  10자리를 확보하고 오른쪽부터 문자를 채움
print('%10s' % ('nice1111'))    # 위 명령어 비교

print('{:10}'.format('nice'))   # 10 자리를 확보하고 왼쪽부터 출력
print('{:<10}'.format('nice'))  # 10 자리를 확보하고 왼쪽 " <"  부터 출력
print('{:>10}'.format('nice'))   # 10 자리를 확보하고 오른쪽 ">" 부터 출력


print('%10s' % ('nice'))         # <--- 여기서 10은 10개의 자리수를 의미  10자리를 확보하고 오른쪽부터 문자를 채움
print('{:>10}'.format('nice'))   # 10 자리를 확보하고 오른쪽 ">" 부터 출력

print('%-10s' % ('nice'))       # 음수는 왼쪽부터 문자를  출력함  
print('{:10}'.format('nice'))    # format 함수는  문자를 받아서  


print('{:_<10}'.format('nice'))   # 10자리 확보하고 문자를 오른쪽에 붙여 출력후 나머지는 _ 로 채움
print('{:_>10}'.format('nice'))  # 10자리 확보하고 문자를 왼쪽에 붙여 출력후 나머지는 _ 로 채움
print('{:^10}'.format('nice'))  # 중앙 정렬
print('{:_^10}'.format('nice'))  

print('%.5s' % ('nice'))
print('%.5s' % ('pythonstudy'))
print('%5s' % ('pythonstudy'))  # .을 붙이지 않으면 자릿수 만큼 절삭하지 않는다.

print('{:.5}'.format('pythonstudy'))
print('{:10.5}'.format('pythonstudy'))   #총 10글자 자리를 확보하고 .5   다섯글자 만큼 절삭하여 출력

# %d  정수
print('%d %d' % (1, 2))
print('{} {}'.format(1, 2))
print('{1} {0}'.format(1, 2))   # 순서 바꾼거


print('%4d' % (42))   #4자리 확보하고 정수 출력
print('%4d' % (42981798))   # . 이 붙지 않았기 때문에 그냥 출력
print('{:4d}'.format(42))   
print('{:4d}'.format(4211111))  


# %f  실수  정수부. 소수부를 지정 해줄 수 있다 소수부의 default  값을 6자리이다
print('%f' % (3.141592653589793))
print('{:f}'.format(3.141592653589793))  
     
print('%1.8f' % (3.141592653589793))     # 정수부는 1자리 소수부는 8자리


print('%06.2f' % (3.141592653589793))   #  6자리 확보하고 오른쪽에 붙여서 실수부 14 출력 하고 나면 . 오른쪽에 정수부를 출력 후 나머지 영역을 0 을 붙여 출력
print('%6.2f' % (3.141592653589793))    #위 결과와 비교 필요
print('{:06.2f}'.format(3.141592653589793))

# 파이썬 기초
# 파이썬 변수

# 기본 선언
n = 700
>>> n = 700
>>> n    
700
>>> print(n)
700
>>> print(type(n))
<class 'int'>
>>> print(id(n))   
1873258010832


# 출력
print(n)
print(type(n))

# 동시 선언
x = y = z = 700
>>> x = y = z = 700
>>> print(x,y,z)
700 700 700
>>> print(id(x)) 
1873258010992
>>> print(id(y)) 
1873258010992
>>> print(id(z)) 
1873258010992
>>> a = 70 
>>> b = 70
>>> print(id(a))
1873256974736
>>> print(id(b))
1873256974736
>>> a = 70 
>>> b = 80
>>> c = 70
>>> print(id(a)) 
1873256974736
>>> print(id(b)) 
1873256975056
>>> print(id(c)) 
1873256974736   <---- object 오브젝트 




# 출력
print(x, y ,z)

#선언
var = 75

# 출력
print(var)
print(type(var)

# 재 선언
var = "Change Value"

# 출력
print(var)
print(type(var))


# Object References
# 변수 값 할당 상태
# 1. 타입에 맞는 오브젝트 생성
# 2. 값 생성
# 3. 콘솔에 출력

# 예1)
print(300)

# 예2)
# n -> 777
n = 777

print(n)
print(type(n))

m = n
# m-> 777 <- n

print(m, n)
print(type(m), type(n))

m = 400
# m-> 400, 777 <-n

print(m)
print(type(m))


# id(identity)확인 : 객체의 고유값 확인
m = 800
n  = 655

print(id(m))
print(id(n))


m = 800
n  = 800

# 같은 오브젝트 참조
print(id(m))
print(id(n))

# 다양한 변수 선언
# Camel Case :  numberOfCollegeGraduates 
# Pascal Case :  NumberOfCollegeGraduates   
# Snake Case :  number_of_college_graduates 

# 허용하는 변수 선언 법
age = 1
Age = 2
aGe = 3
AGE = 4
a_g_e = 5
_age = 6
age_ = 7
_AGE_ = 8

숫자문자
1a = 1     X



# 예약어는 변수명으로 불가능
"""
False	def	if	raise
None	del	import	return
True	elif	in	try
and	else	is	while
as	except	lambda	with
assert	finally	nonlocal	yield
break	for	not	
class	from	or	
continue	global	pass	
"""
int = 1
var = 1 

# 숫자형

# 파이썬 지원 자료형
'''
int : 정수
float : 실수
complex : 복소수
bool : 불린   참 거짓 
str : 문자열(시퀀스)   
list : 리스트(시퀀스)     시퀀스의 특징  순서가 존재하고 여러가지 데이터 타입을 담을 수 있습니다.
tuple : 튜플(시퀀스)
set : 집합
dict : 사전
'''

# 데이터 타입
str1 = "Python"
bool = True
str2 = "Anaconda"
float = 10.0
int = 7
list = [str1, str2]
dict = {
    "name": "Machine Learning",
    "version": 2.0
}
tuple = 3, 5, 7
set = {7, 8, 9}

# 데이터 타입 출력
print(type(str1))
print(type(bool))
print(type(str2))
print(type(bool))
print(type(float))
print(type(int))
print(type(dict))
print(type(tuple))
print(type(set))

# 숫자형 연산자
"""
+ 
- 
* 
/ 
// : 몫 
% : 나머지
abs(x) 
int(x) 
float(x) 
complex(x)
pow(x, y) 
x ** y : 제곱  x^y  x의  y 승 
....
"""

# 정수 선언
i = 77
i2 = -14
big_int = 999999999999999999999999999999999999999

# 정수 출력
print(i)
print(i2)
print(big_int)

# 실수 선언
f = 0.9999
f2 = 3.141592
f3 = -3.9
f4 = 3 / 9

# 실수 출력
print(f)
print(f2)
print(f3)
print(f4)

# 연산 실습
i1 = 39
i2 = 939
big_int1 = 123456789123456789012345678901234567890
big_int2 = 999999999999999999999999999999999999999
f1 = 1.234
f2 = 3.939

# +
print(">>>>> + ")
print("i1 + i2 : ", i1 + i2) 
print("f1 + f2 : ", f1 + f2) 
print("big_int1 + big_int2 : ", big_int1 + big_int2) 

# -
print(">>>>> -")
print("i1 - i2: ", i1 - i2) 
print("f1 - f2: ", f1 - f2)
print("big_int1 - big_int2: ", big_int1 - big_int2)

# *
print(">>>>> *")
print("i1 * i2: ", i1 * i2)
print("f1 * f2: ", f1 * f2)
print("big_int1 * big_int2: ", big_int1 * big_int2)

# /
print(">>>>> /")
print("i2 / i1: ", i2 / i1)
print("f2 / f1: ", f2 / f1)
print("big_int2 / big_int1: ", big_int2 / big_int1)

# //
print(">>>>> //")
print("i2 // i1: ", i2 // i1) 
print("f2 // f1: ", f2 // f1)
print("big_int2 // big_int1: ", big_int2 // big_int1)

# %
print(">>>>> %")
print("i1 % i2 :", i1 % i2)
print("f1 % f2 :", f1 % f2)
print("big_int1 % big_int2 :", big_int1 % big_int2)

# **
print(">>>>> **")
print("2 ** 3: ", 2 ** 3)
print("i1 ** i2: ", i1 ** i2) 
print("f1 ** f2: ", f1 ** f2)

# 형 변환 실습
a = 3.
b = 6
c = .7
d = 12.7

# 타입 출력
print(type(a), type(b), type(c), type(d))

# 형 변환
print(float(b))  # 정수 -> 실수
print(int(c))  # 실수 -> 정수
print(int(d))  # 실수 -> 정수
print(int(True))  # Bool -> 정수
print(float(True))  # Bool -> 정수
print(int(False))  # Bool -> 정수
print(float(False))  # Bool -> 정수
print(complex(3))  # 정수 -> 복소수
print(complex('3'))  # 문자 -> 복소수
print(complex(False))  # Bool -> 복소수

# 수치 연산 함수
print(abs(-7))
x, y = divmod(100, 8)
print(x, y)
print(pow(5, 3))

#외부 모듈
import math

#ceil
print(math.ceil(5.1))   # x 이상의 수 중에서 가장 작은 정수

#floor

#pi
print(math.pi)


# 진수

octal1 = 0o177
print(octal1)

hex1 = 0x111
print(hex1)

# 파이썬 문자형
# 문자형 중요

# 문자열 생성
str1 = "I am Python."
str2 = 'Python'
str3 = """How are you?"""
str4 = '''Thank you!'''

# 문자열 출력
print(type(str1))
print(type(str2))
print(type(str3))
print(type(str4))

# 문자열 길이
print(len(str1))
print(len(str2))
print(len(str3))
print(len(str4))

# 빈 문자열
str_t1 = ''
str_t2 = str()

print(type(str_t1), len(str_t1))
print(type(str_t2), len(str_t2))

# 이스케이프 문자 사용
"""
참고 : Escape 코드

\n : 개행
\t : 탭
\\ : 문자
\' : 문자
\" : 문자
\000 : 널 문자
...

"""

escape_str1 = "Do you have a \"retro games\"?"
escape_str2 = 'What\'s on TV?'


# 출력1
print(escape_str1)
print(escape_str2)

# 탭, 줄바꿈
t_s1 = "Click \tStart!"
t_s2 = "New Line\n Check!"

# 출력2
print(t_s1)
print(t_s2)

# Raw String
raw_s1 = r'D:\Python\python3'
raw_s2 = r"\\x\y\z\q"


# Raw String 출력
print(raw_s1)
print(raw_s2)


multi_str1 = \
    """
    문자열
    멀티라인 입력
    테스트
    """
# 멀티라인 출력
print(multi_str1)

multi_str2 = \
    '''
    문자열 멀티라인 
    역슬래시(\) \
    테스트
    '''
# 멀티라인(역슬래시) 출력
print(multi_str2)

# 문자열 연산
str_o1 = "Python"
str_o2 = "Apple"
str_o3 = "How are you doing?"
str_o4 = "Seoul Deajeon Busan Jinju"

print(3 * str_o1)
print(str_o1 + str_o2)
print(dir(str_o1))
print('y' in str_o1)
print('n' in str_o1)
print('P' not in str_o2)

# 문자열 형 변환
print(str(66))  # type 확인
print(str(10.1))
print(str(True))
print(str(complex(12)))

# 문자열 함수(upper, isalnum, startswith, count, endswith, isalpha 등)
print("Capitalize: ", str_o1.capitalize())
print("endswith?: ", str_o2.endswith("s"))
print("join str: ", str_o1.join(["I'm ", "!"]))
print("replace1: ", str_o1.replace('thon', ' Good'))
print("replace2: ", str_o3.replace("are", "was"))
print("split: ", str_o4.split(' '))  # Type 확인
print("sorted: ", sorted(str_o1))  # reverse=True
print("reversed1: ", reversed(str_o2)) #list 형 변환
print("reversed2: ", list(reversed(str_o2)))

# 반복(시퀀스) 설명
im_str = "Good Boy!"

print(dir(im_str))  # __iter__ 확인

# 출력
for i in im_str:
    print(i)


# 슬라이싱
str_sl = 'Nice Python'

# 슬라이싱 연습
print(str_sl[0:3])
print(str_sl[:len(str_sl)])
print(str_sl[:len(str_sl) - 1])
print(str_sl[:])
print(str_sl[1:4:2])
print(str_sl[-4:-2])
print(str_sl[1:-2])
print(str_sl[::-1])
print(str_sl[::2])


# 아스키코드
a = 'z'

print(ord(a))
print(chr(122))

----------------------------------------
===== 문자열 실습 문제==========
-------------------------
a=abcedf 문자열
b=12345 문자열
-------------------------
a문자열과 b문자열을 더한 문장을 가지고 c 문자열을 만드시오.

a="abcedf"
b="12345"
c=a+b

print(c)

abcedf12345
01234567890
10987654321 -

b문자열을 3번 반복하시오.

b*3

c문자열 대상

c문자열에서 3번째 문자를 인덱싱 해보시오.
           2 
c[2]

3번째,5번째,8번째 문자를 인덱싱 해보시오.
2     4     7
c[2]
c[4]
c[7]

4,7,8 번째 문자들을 추출해서 한 문자열로 만들어보시오.
3 6 7
c[3]+c[6]+c[7]

뒤에서 4번째 문자를 인덱싱 해보시오.

c[-4]

3번째 문자부터 끝까지 슬라이싱해보시오.
2
c[2:]

4번째부터 8번째 문자까지 슬라이싱해보시오.
3        7
c[3:8]

뒤에서 3번째부터 6번째까지 슬라이싱해보시오.

c[-6:-2]

전체 문자열을 슬라이싱 해보시오.

c[:]

c[-6:-2]


===== 문자열 포맷팅 실습  ===========

"나는 아침마다 1잔의 우유를 마시고 네이버뉴스를 봅니다." 에서 1과 네이버뉴스를 포맷팅을 이용해서 작성해보시오.

print("나는 아침마다 %d의 우유를 마시고 %s를 봅니다."%(1,"네이버뉴스"))

'hello'문자열을 총 14칸으로 설정하고 왼쪽 붙임으로 포맷팅을 이용해서 작성해보시오.

print("%-14s"%"hello")

'bye' 문자열을 총 10칸으로 설정하고 오른쪽 붙임으로 포맷팅을 이용해서 작성해보시오.

print("%10s"%'bye')

2.5679856 라는 소수를 소수점 5자리까지만 출력되도록 포맷팅을 이용해서 작성해보시오.

print("%0.5f"%2.5679856)

총 15칸으로 설정하고 소수점 3자리리까지만 출력되도록 포맷팅을 이용해서 작성해보시오.

print("%15.3f"%2.5679856)


==== 문자열 함수 실습=====

string1 = "My life is mine."

string1을 소문자를 모두 대문자로 변환한 값을 string2로 만드시오.

string2=string1.upper()

string2을 대문자를 모두 소문자로 변환한 값을 string3로 만드시오.

string3=string2.lower()

string1을 소문자는 대문자로, 대문자는 소문자로 변환한 값을 string4로 만드시오.

string4=string1.swapcase()

string2에서 m의 갯수는?

string2.count('m')

string3에서 M 이 처음으로 나오는 자리는?

string3.find('M')

string3.index('M')

12345 사이에 ; 으로 구분자를 만드시오.

';'.join('12345')

string1에서 My를 Your로 변환시켜서 string4에 넣으시오.

string1.replace("My","Your")

"192.168.100.40" 을 리스트 형태로 만들어보시오.

"192.168.100.40".split('.')

"abcdef"를 리스트 형태['a','b','c','d','e','f']로 만들어보시오.

" ".join("abcdef").split()

# "192.168.100.40" 을 리스트 형태로 만들어보시오.
print("192.168.100.40".split('.'))
# "abcdefg"  를 리스트 형태로 만드세요.
print("abcdefg".split())  #
print(" ".join("abcdef"))
print(" ".join("abcdef").split())

# 파이썬 리스트
# 자료구조에서 중요 
# 외부 모듈을 이용해서 array 를 이용하여 배열을 쓸수 있지만 기본 python 에서는 리스트를 이용 
# 리스트 자료형(순서O, 중복O, 수정O, 삭제O)

# 선언
#빈 리스트 선언
a = []
print(type(a))
b = list()


c = [70, 75, 80, 85]
print(len(c))  #<--  확인   str 스트링과 동일 하다 시퀀스 형이기 때문에 len 메소드 사용가능
d = [1000, 10000, 'Ace', 'Base', 'Captine']
e = [1000, 10000, ['Ace', 'Base', 'Captine']]   # <-- 리스트 안에 리스트
f  = [21.42, 'foobar', 3, 4, 'bark', False, 3.14159]

# 인덱싱
print('>>>>>>')
print('d - ', type(d), d)
print(type(d[1]))
print(type(d[3]))

print('d - ', d[1])  # <--- 리스트 d 에서 10000 가져오기
print('d - ', d[0] + d[1] + d[1]) 
print('d - ', d[-1])   #  'Captine 을 가리킴
print('e - ', e[-1][1])  #  [-1]  은  ['Ace', 'Base', 'Captine']  [1]  Base 를 가리킴  -  중접된 리스트
print('e - ', type(e[-1][1]))  # 현재 base 는 문자형이다. 
print('e - ', list(e[-1][1]))  # 이걸 list 형 변환을 주면     시퀀스 형이기 때문에  ['B', 'a', 's', 'e']  리스트 형태로 변환   <--- 자주 사용하는 기능

# 슬라이싱
print('>>>>>>')
print('d - ', d[0:3])  # 슬라이싱은 3은 0 ~ 3 이 아닌 0,1, 2 까지 나옴
print('d - ', d[2:])  # : 만 쓰면 끝까지를 나타냄
print('e - ', e[-1][1:3])  #  ['Ace', 'Base', 'Captine']  영역에서 1,2 를 출력

# 리스트 연산
print('>>>>>>')
print('c + d - ', c + d)  #리스트 + 리스트 = 리스트 
print('c * 3 - ', c * 3) # 리스트 반복  순서는 유지됨 
# print("c[0] + 'hi' - ",c[0] + 'hi') 
print("'Test' + c[0] - ", 'Test' + c[0])   # <--- 에러가 발생 이유는? 
print(type(c[0]))  #<----   int  문자 str 과 합칠수 없음  아래 처럼 형변환을 통해 해결 
print("'Test' + c[0] - ", 'Test' + str(c[0]))

# 값 비교 
print(c == c[:3] + c[3:])
증명
print(c)
print(c[:3] + c[3:]))



# 같은 id 값
temp = c
print(c == temp)
print(id(temp))
print(id(c))     # 파이썬은 효율을 위해서 이렇게 사용한다 한 객채의 값을 변경 하면 id 가 같기 때문에 같이 변경된다. 

 

# 리스트 수정, 삭제
print('>>>>>>')
c[0] = 4  # 리스트 인덱스 값 수정
print('c - ', c)
 
c[1:2] = ['a', 'b', 'c']    #  c[1:2]는 c[1]을 의미 c = [70, 75, 80, 85] 중 1:2 1에서 1을 가리키는 것으로 결국 75를 의미 그    리스트 인덱스 값을 선언
print('c - ', c)
c[1:2] = [['a', 'b', 'c']]   # [['a', 'b', 'c']]  리스트 안에 리스트 선언 
print('c - ', c)
c[1] = ['a', 'b', 'c']  #맨위 형식과 같은 결과 
print('c - ', c)

c[1:3] = []  # 1,2 영역을 비움  
print('c - ', c)

del c[3]    #  
print('c - ', c)

# 리스트 함수
a = [5, 2, 3, 1, 4]
print('a - ', a) 

#추가를 하기 위해 아래와 같이 하면 될것 같지만 되지 않음 
a[5] = 10 
print('a - ', a)

a.append(6)    # 뒤에 추가  append  함수 이용
print('a - ', a)

a.sort()      # 오름차순
print('a - ', a)

a.reverse()  # 내림차순   데이터가 많아 진다면 속도가 느려지게 된다.  sort 나 reverse 는
print('a - ', a)
print('a - ', a.index(5))
print('a - ', a[5])


print('a - ', a)
a.insert(2, 7)  #  리스트 인덱스 중간에 값을 삽입  2번째 위치에 7을 삽입
print('a - ', a)

a.reverse()

#del c[3]    #  del 이라는 예약어는  일일이 리스트에 담겨있는 정보를 확인해서 삭제 해야 하기 때문에 비효율적 
#print('c - ', c)

a.remove(1)  #1이라는 문자를 삭제
print('a - ', a)

print('a - ', a.pop())   # pop 은 마지막에 있던 원소를 꺼내오고 기존의 리스트에서 제거
print('a - ', a)

print('a - ', a.pop())   # stack  처럼  last in , first out  마지막에 들어온 원소가 가장 먼저 나감  LIFO
print('a - ', a)

print('a - ', a.count(4)) # 리스트 원소중에  4 가 몇개나 있는지 카운트

ex = [8, 9]  
a.extend(ex)   # 현재 리스트 원소 를 확장   위에 추가를 할때   c[1:2] = ['a', 'b', 'c']  또는 c[1] = ['a', 'b', 'c']  선언 할 수 있지만  extend 함수를 이용하여 확장 
print('a - ', a)

# 삭제 remove(원하는 값을 바로 삭제) , pop(끝에있는것만 삭제), del (인덱스 번호를 확실히 알아야 함)

# 반복문 활용
while a:
    l = a.pop()
    print(2 is l)


===== list 실습 ====

number=[1,2,3,4,5,6,7,8,9,10]
alpha=['a','b','c','d','e']

# 1 number 와 alpha 를 합쳐서 numalp 리스트 생성
numalp = number + alpha
print(numalp)

# 2 numalp 리스트에서 9번 자리부터 11 자리 삭제
numalp[9:12] = []
print(numalp)

# 3 8번 자리에 [11,12,13] 리스트 형태로 추가
numalp[8] = [11,12,13]
print(numalp)
# 4 1,2,3 번 자리에 구성요소를 21,22,23 으로 교체
numalp[1:4] = [21,22,23]
print(numalp)
# 5 numalp 리스트 끝에 100 추가 
numalp.append(100)
print(numalp)
# 6 number 리스트에서 모든 구성요소 모두 삭제 
number[:] = []
print(numalp)

# 7 numalp 리스트를 순서대로 정렬  (에러 발생)
numalp.sort()
에러
=> 숫자형과 문자열이 섞여있기 때문에

# 7.2 numalp 리스트를 역순서대로 정렬
numalp.reverse()

# 8 ['ㄱ','ㄴ','ㄷ'] 리스트를 2번과 3번 사이에 삽입
numalp.insert(2,['ㄱ','ㄴ','ㄷ'])
print(numalp)
# 9 ['ㄱ', 'ㄴ','ㄷ'] 을 뽑는 형태로 pop()로 추출
numalp.pop(numalp.index(['ㄱ', 'ㄴ','ㄷ']))
print(numalp)

# 번외 문제
numalp 리스트의 순서를 거꾸로 바꿔서 numalp1을 만들어보시오.(단, 기존과 다른 방법=> reverse()를 이용하지 말고 (hint:for))

numalp1=[]

for i in numalp:
	numalp1.insert(0,i)

print(numalp1)

alpha 리스트를 3번 곱해서 alpha3을 만들고 해당 리스트를 이용해서 문자열 "aaabbbcccdddeee"를 만들어 보시오.

string1=""

alpha=['a','b','c','d','e']

alpha3=alpha*3

alpha3=['a','b','c','d','e','a','b','c','d','e','a','b','c','d','e']

for x in alpha:
	for y in alpha3:
		if x == y :
			string1=string1+y
print("alpha3 : {}".format(alpha3)) 
=> alpha3 : ['a','b','c','d','e','a','b','c','d','e','a','b','c','d','e']
print(string1)

string2=""

for x in alpha:
	while x in alpha3:
		string2=string2+alpha3.pop(alpha3.index(x))

print("alpha3 : {}".format(alpha3))
=>alpha3 : []
print(string1)

# 파이썬 튜플
# 리스트와 비교 중요 
# 튜플 자료형(순서O, 중복O, 수정X,삭제X)  <--- 중요 [ 불변 - immutable ]  중요데이터를 저장하고 변경하지 않을때 사용

# 선언
a = ()
b = (1,)  #<--- 주의 원소가 하나일때는 , 를 찍어줘야 함
print(type(a), type(b))

c = (11, 12,13,14)
d = (100, 1000,'Ace', 'Base', 'Captine')
e = (100, 1000, ('Ace', 'Base', 'Captine'))


# 수정 X
# d[0] = 1500
# print('d - ', d)

# 삭제 X
# d.remove(1000)
# print('d - ', d)
# list 형변환을 통한   수정과 삭제

d = list(d)
print(type(d))
d.append(10000)
d = tuple(d)
print(type(d), d)

d = list(d)
print(type(d))
d.remove(1000)
d = tuple(d)
print(type(d), d)

# 인덱싱
print('>>>>>')
print('d - ', type(d), d)
print('d - ', d[1])
print('d - ', d[0] + d[1] + d[1])
print('d - ', d[-1])
print('e - ', e[-1])
print('e - ', e[-1][1])
print('e - ', list(e[-1][1]))   # list 형변환  이렇게 하면 수정, 삭제의 특징이 사라짐


# 슬라이싱
print('>>>>>')
print('d - ', d[0:3])
print('d - ', d[2:])
print('e - ', e[2][1:3])

# 튜플 연산
print('>>>>>')
print('c + d - ', c + d)
print('c * 3 - ', c * 3)
# print("c[0] + 'hi' - ",c[0] + 'hi')
print("'Test' + c[0] - ", 'Test' + str(c[0]))

# 튜플 함수
a = (5, 2, 3, 1, 4, 2)
print('a - ', a)

print('a - ', a[3])
print('a - ', a.index(3))   # 숫자 3이 들어가 있는 위치
print('a - ', a.count(4))

# 튜플 완전 삭제
del d
print( type(d), d)

tuple(튜플)은 불변한 순서가 있는 객체의 집합입니다.
list형과 비슷하지만 한 번 생성되면 값을 변경할 수 없습니다.
REPL에서 확인해봅니다.

list와 마찬가지로 다양한 타입이 함께 포함될 수 있습니다.

# 팩킹 & 언팩킹(Packing, and Unpacking)   많은 파이썬 기초 강좌에 팩킹과 언팩킹에 대해서 언급 되지 않는다 하지만 초반에 정의를 잘 해주어야 되는 주제기 때문에 정리 필요
# 패킹은 말그대로 묶는다는 뜻이고, 언패킹은 묶여있는 것을 풀어내는 뜻이다.
# 튜플로 값을 묶는 것을 튜플 패킹, 튜플로 묶여있는 값을 풀어내는 것을 튜플 언패킹이라한다.

# 팩킹
t = ('foo', 'bar', 'baz', 'qux')

# 출력 확인   인덱싱이 가능 
print(t)
print(t[0])
print(t[-1])

# 언팩킹1
(x1, x2, x3, x4) = t    # 사실 괄호를 제거해서 x1, x2, x3, x4 = t 도 가능하다 하지만 관습상  (x1, x2, x3, x4) = t  통해 언패킹 됨을 확인 

# 출력확인
print(type(x1), type(x2), type(x3), type(x4))
print(x1, x2, x3, x4)


# 언팩킹2
(x1, x2, x3, x4) = ('foo', 'bar', 'baz', 'qux')

# 출력 확인
print(x1, x2, x3, x4)

# 팩킹 & 언팩킹
t2  =1, 2, 3     #  t2 = (1, 2, 3) 괄호를 씌워주어도 튜플이고 안씌워줘도 튜플
t3 = 4,   #여기도 t3 = (4,)  와 같다
x1, x2, x3 = t2
x4, x5, x6 = 4, 5, 6

# 출력 확인
print(t2)
print(t3)
print(x1,x2,x3)
print(x4,x5,x6)




human = (180,75) # 사람의 키와 몸무게로 튜플을 묶으면 튜플 패킹
print(human) # (180, 75)
human = 180,75 # 튜플 패킹은 소괄호가 없어도 된다.
print(human) # (180, 75)
튜플 패킹은 간단하다.

언패킹도 간단하다. 아래 예시를 보자.
height, weight = human # 튜플 언패킹
print(height, weight) # 180 75
언패킹의 과정에서 둘 이상의 값을 리스트로 묶는 것도 가능하다.
중요한 점은, 튜플이 아닌 리스트로 묶인다는 사실이다.
아래 예시를 보자.
num = 1, 2, 3, 4, 5, 6, 7
n1, n2, *others = num

print(n1)  # 1
print(n2)  # 2
print(others)  # [3,4,5,6,7]
맨 뒤쪽에 있는 값들만 리스트로 묶을 수 있는 것이 아니라, 중간 값이나 앞에 위치한 값들도 묶을 수 있다.
단 일부를 리스트로 묶을 때는, * 를 사용한다.
참고로, 리스트 역시 언패킹이 가능하다.
num = [1, 2, 3]
n1, n2, n3 = num
print(n1) # 1
함수에서의 패킹,언패킹
함수의 호출, 반환에서도 튜플 패킹과 언패킹을 할 수 있다.
def make_tuple():
    return 1, 2, 3

nums = make_tuple()
print(nums)  # (1,2,3)

n1, *others = make_tuple() # 반환되는 튜플을 언패킹하여 저장할 수도 있다.
print(n1) # 1
print(others) # [2, 3]
지금까지 *를 사용하면 남은 값들을 리스트로 패킹하는 형태로 사용되었다.
하지만 *는 사용위치에 따라 튜플 패킹이나 언패킹으로 쓰일 수 있다.
def sum(*others):
    print(others) # (1,2,3,4,5) -> 튜플 패킹

sum(1, 2, 3, 4, 5)

def show(height, weight):
    print(height)
    print(weight)

human = 180,75
show(*human) # human에 담긴 값을 언패킹하여 각각 매개변수에 전달한다.
중첩 튜플의 패킹, 언패킹
튜플안에 튜플이 존재하는 중첩 튜플에서 패킹, 언패킹은 어떻게 진행할까?
모양 그대로 하면된다.
바로 예시로 살펴보자.
tu = ((1, 2), 3, (4, 5))
(t1, t2), t3, (t4, t5) = tu
print(t1, t2, t3, t4, t5) # 1 2 3 4 5

언패킹의 관례
언패킹 과정에서, 모든 값이 필요하지 않고 필요한 정보만 사용하고 싶을 땐 어떻게 할까?
관례적으로 사용하지 않는 값들에 대해서는 _ 변수에 담는다.
human = ('james', 180, 75, 20) # 순서대로 이름, 키, 몸무게, 나이라고 하자

_, _, _, age = human # 나이만 변수에 담고싶을 때는 관례적으로 이렇게 한다.
print(age) # 20
물론 _ 역시도 변수이지만, 잘쓰지 않는 형태이기때문에 관례적으로 이런 방식을 사용한다.
for 루프에서의 언패킹
for 루프에서도 역시 언패킹을 할 수 있다.
data = [('james',20),('john',21),('peter',15)]

for name,age in data:
    print(name, age)

------------------------------------------------------------------
==== 튜플 실습 ====

a=('a1','a2','a3','a4')
b=('b1','b2','b3','b4')

# 1. q, w, e, r 변수에 튜플 a의 구성요소들을 차례대로 하나씩 넣으시오.
q,w,e,r = a
print(q, w, e, r)
# 2.  a와 b를 더한 값을 c에 넣으세요.
c = a + b
print(c)
# 3.  4번째 구성요소 제거해 볼 것   에러가 나는 원인을 이해하고 list로 형 변환 해서  해결
del a(3)


c의 3번째 자리의 구성요소는 무엇인가?
    2
c[2]

6번째 부터 끝까지의 구성요소는 무엇인가?
5
c[5:]

처음부터 3번째의 구성요소는 무엇인가?
         2
c[:3]

('a','b','c',[1,2,3,4]) 에서 튜플안의 리스트 구성요소 중 1,2를 문자열 형태로 바꾸어 보시오.

d=('a','b','c',[1,2,3,4])
d[3][:2]=['1','2']

# 파이썬 딕셔너리
# 범용적으로 가장 많이 사용
# 딕셔너리 자료형(순서X, 키 중복X, 수정O, 삭제O)
#

# 선언
# () 튜플  [] 리스트 {} 집합, 딕셔너리
# a = {'name': 'Kim', 'name': '01012345678' }  <--- 키가 중복되면 안된다.
# key : value   ,키는 숫자 문자 다된다. 
# 키만 존재 하면  value 엔 어떤 자료형이라도 좋다. 

a = {'name': 'Kim', 'phone': '01012345678', 'birth': '870124'}
b = {0: 'Hello python!'}
c = {'arr': [1, 2, 3, 4]}
d = {
	 'Name' : 'Niceman',
	 'City'   : 'Seoul',
	 'Age': '33',
	 'Grade': 'A',
	 'Status'  : True
}
# dict 리스트에 튜플 형태로 선언 . 자주 사용하는 형태가 아니다. 가독성이 떨어진다. 
e =  dict([			
	 ( 'Name', 'Niceman'),
	 ('City', 'Seoul'),
	 ('Age', '33'),
	 ('Grade', 'A'),
	 ('Status', True)
])

f =  dict(
	 Name='Niceman',
	 City='Seoul',
	 Age='33',
	 Grade='A',
	 Status=True
)

# 만약 f1 부터 f100 까지 있다면  리스트 안에 a = [ f1, f,2 ... f100 ]  형태로 자료를 저장하고 관리 하면 효율적으로 사용
# java 에서는 맵 , 웹에서 자주 사용하는 json 형태로 많이 사용


print('a - ', type(a), a)
print('b - ', type(b), b)
print('c - ', type(c), c)
print('d - ', type(d), d)
print('e - ', type(e), e)
print('f - ', type(f), f)

# 출력
print('a - ', a['name'])  # 존재X -> 에러 발생
print('a - ', a.get('name'))  # 존재X -> None 처리.  
print('b - ', b[0]) 
print('b - ', b.get(0))
print('c - ', c['arr'])
print('c - ', c['arr'][3])
print('c - ', c.get('arr'))
print('d - ', d.get('Age'))
print('e - ', e.get('Grade'))
print('f - ', f.get('City'))

# 딕셔너리 추가
a['address'] = 'seoul'  #address 키가 존재 하지 않는데  추가를 하면  등록됨
a['name'] = 'seoul'   # 키가 존재하면 값을 수정
print('a - ', a)
a['rank'] = [1, 2, 3]
print('a - ', a)

# 딕셔너리 길이  - 시퀀스 형이기 때문에 len 을 이용한 길이를 쓸수 있다.  
# 키의 갯수를 확인 할 수 있다.
print(len(a))
print(len(b))
print(len(d))
print(len(e))


# dict_keys, dict_values, dict_items : 반복문(iterate) 사용 가능    dir 함수로  __iter__ 있으면 반복문에서 사용할 수 있다. 
print('a - ', a.keys())
print('b - ', b.keys())
print('c - ', c.keys())
print('d - ', d.keys())

print('a - ', list(a.keys()))   # 리스트로 변환 
print('b - ', list(b.keys()))
print('c - ', list(c.keys()))
print('d - ', list(d.keys()))

print('a - ', a.values())
print('b - ', b.values())
print('c - ', c.values())
print('d - ', d.values())

print('a - ', list(a.values()))
print('b - ', list(b.values()))
print('c - ', list(c.values()))
print('d - ', list(d.values()))

print('a - ', a.items())  # 키와 밸류가 한쌍의 튜플로 감싸고 리스트 형태로 출력
print('b - ', b.items())
print('c - ', c.items())
print('d - ', d.items())

print('a - ', list(a.items()))
print('b - ', list(b.items()))
print('c - ', list(c.items()))
print('d - ', list(d.items()))

print('a - ', a.pop('name'))
print('a - ', a)

print('b - ', b.pop(0))
print('c - ', c.pop('arr'))
print('c - ', c)
print('d - ', d.pop('City'))

print('f - ', f.popitem())  # popitem 는 무작위로 추출 . 딕셔너리는 순서가 없어서
print('f - ', f.popitem())
print('f - ', f.popitem())
print('f - ', f.popitem())
print('f - ', f.popitem())
# 예외
# print('f - ', f.popitem())

print('a - ', 'name' in a)  # 키가 존재하는지 체크 
print('a - ', 'birth2' in a)
print('a - ', 'addr' in a) 
print('a - ', 'City' in d)  #

# 수정 
a['test'] = 'test_dict'
print('a - ',  a)

a['address'] = 'dj'
print('a - ',  a)

a.update(birth='900101')  # 메소드를 이용한  수정
print('a - ',  a)

temp = {'address': 'Busan'}
a.update(temp)
print('a - ',  a)



f.update(Age=36)   

temp = {'Age': 27} 
print('f - ', f)

f.update(temp)

print('f - ', f)


-----------------------------------------
==== 딕셔너리 실습 ====

srp={'가위':'보','바위':'가위','보':'바위'}

srp의 key list 생성

list(srp.keys())

srp의 value list 생성

list(srp.values())

srp의 key와 value 의 한쌍으로된 리스트 생성

list(srp.items())

srp의 key '가위'에 해당하는 value 출력

srp['가위']

srp에 '찌':'빠', '묵':'찌', '빠':'묵' 추가

srp['찌']='빠'
srp['묵']='찌'
srp['빠']='묵'

srp 보자기 라는 키가 있는지 확인

'보자기' in srp

'가위'라고 하는 value값에 해당하는 key 값을 찾도록 함수를 만들어보시오.

첫번째 방법

def valuetokey(b):
	if b in srp.value():
		i=list(srp.keys())[list(srp.values()).index[b]]
		return i

두번째 방법

def valuetokey(b):
	for i in srp.keys():
		if srp.get(i) == b:
			return i

세번째 방법

def valuetokey(b):
	for i,j in srp.items():
		if j==b:
			return i


===============================================
value='보'
key=valuetokey(value)

print("{}의 key 값은 {} 입니다.".format(value,key))
===================================================

# 집합(Sets) 특징   
# 딕셔너리, 리스트, 튜플에서 각 각 특징을 가짐   
# 선형대수학, 데이터 분석에서 numpy, scipy (싸이파이) 를 이용해서 사용
# 집합(Sets) 자료형(순서X, 중복X)  집합에서는 어떤 원소가 존재하는 지가 더 중요

# 선언
# () 튜플  []  리스트  {} 딕셔너리, 집합
a = set()   
b = set([1, 2, 3, 4])
c = set([1, 4, 5, 6])
d = set([1, 2, 'Pen', 'Cap', 'Plate'])  # 서로 다른 자료형 선언 가능
e = {'foo', 'bar', 'baz', 'foo', 'qux'}  # 딕셔너리와 다른부분은 키가 없고 리스트 처럼  { } 안에서 나열
f = {42, 'foo', (1, 2, 3), 3.14159}

print('a - ', type(a), a)

# b = set([1, 2, 3, 4, 4, 4, 4])    # 중복을 허용 하지 않는다.
print('b - ', type(b), b)
# print('b - ', type(b), b, 2 in a)    # in 연산자도 사용할 수 있다.  
# print('b - ', type(b), b, 2 in b)    # 튜플이나 , 리스트, 딕셔너리에서 사용할 수 있는다 다할 수 있다. 
print('c - ', type(c), c)
print('d - ', type(d), d)
print('e - ', type(e), e)
print('f - ', type(f), f)

# 튜플 변환
t = tuple(b)
print('t - ', type(t), t)
print('t - ', t[0], t[1:3])  # 튜플이 되었다는 것은 슬라이싱 할 수 있다는것


# 리스트 변환
l = list(c)
l2 = list(e)
print('l - ', type(l), l)
print('l - ', l[0], l[1:3])
print('l2 - ', type(l2), l2)

# 길이
print(len(a))
print(len(b))
print(len(c))
print(len(d))
print(len(e))
print(len(f))


# 집합 자료형 활용  (교집합(&), 합집합( |). 차집합(-) )
s1 = set([1, 2, 3, 4, 5, 6])
s2 = set([4, 5, 6, 7, 8, 9])

print('s1 & s2 : ', s1 & s2)
print('s1 & s2 : ', s1.intersection(s2))  

print('s1 | s2 : ', s1 | s2)
print('s1 | s2 : ', s1.union(s2))

print('s1 - s2 : ', s1 - s2)
print('s1 -  s2 : ', s1.difference(s2))

# 중복 원소 확인 (교집합인지 확인)
print('l - ', s1.isdisjoint(s2))   # false 가 나올때 중복원소가 존재함을 의미 

# 부분 집합 확인 
#s1 = set([1, 2, 3, 4, 5, 6])
#s2 = set([4, 5, 6])

print('subset ', s1.issubset(s2))   # False   부분집합 체크
print('subset', s2.issubset(s1))   # True
print('superset', s1.issuperset(s2))  


# 추가 & 제거
# set 에서는  add, remove , discard, clear 메소드 하용
s1 = set([1, 2, 3, 4])  
s1.add(5)
print('s1 - ', s1)

s1.remove(2)
print('s1 - ', s1)
# s1.remove(7)   # 없는 원소를 삭제 하려면 keyerror 메시지 발생

s1.discard(3)
print('s1 - ', s1)

#s1.discard(7)    #[중요] 없는 원소를 삭제 하려 해도 에러가 발생하지 않는다.  결국 remove 보다는 discard 사용

# 모두 제거
s1.clear()
print('s1 - ', s1)

a = [1, 2, 3] #리스트도 clear로 삭제 가능
a.clear()
print(a)

--------------------------------------------------------
==== 집합 실습 ====
a = [1,2,3,4] 로 set s1을 생성하시오.

s1=set(a)

b = "aabbccddeeff"로 set s2를 생성하시오.

s2=set(b)

s1 에 a,b,c 를 추가하시오.

s1.add('a')
s1.add('b')
s1.add('c')

or

s1.update(['a','b','c'])

s2 에 1,2를 추가하시오.

s1.update([1,2])

s1과 s2의 교집합을 구하시오.(2가지 방법 모두 )

s1 & s2
s1.intersection(s2)

s1과 s2의 합집합을 구하시오.(2가지 방법 모두)

s1 | s2
s1.union(s2)

s1과 s2의 차집합을 구하시오.(기호)

s1-s2

s2와 s1의 차집합을 구하시오.(함수)

s2.difference(s1)

s2에서 1을 빼보시오.

s2.remove(1)

# 파이썬 제어문
# IF 실습

# 기본 형식

print(type(True))  # 0 이 아닌수,  "abc",  [1,2,3] ,  (1,2,3,)
print(type(False))  # 0, "" , [] , , (),  {}

# 예1
if True:
    print("Good")  # 들여쓰기(Indent) 하지면 에러가 발생

#if false:
#    print("Good")
#if '':
#    print("Good")
#if 'a':
#    print("Good")



if False:
    # 실행 X
    print("Bad")

# 예2
if False:
    # 여기는 실행되지 않음.
    print("Bad")
else:
    # 여기가 실행된다.
    print("Good")

#아래와 비교
if True:
    # 여기는 실행되지 않음.
    print("Bad")
else:
    # 여기가 실행된다.
    print("Good")




# 관계연산자 종류
# >, >=, <, <=, ==, !=


x = 15
y = 10

# == 양 변이 같을 때 참.
print(x == y)

# != 양 변이 다를 때 참.
print(x != y)

# > 왼쪽이 클때 참.
print(x > y)

# >= 왼쪽이 크거나 같을 때 참.
print(x >= y)

# < 오른쪽이 클 때 참.
print(x < y)

# <= 오른쪽이 크거나 같을 때 참.
print(x <= y)

# 참 거짓 판별 종류
# 참 : "values", [values], (values), {values}, 1
# 거짓 : "", [], (), {}, 0, None

city = ""
if city:
    print("You are in:", city)
else:
    # 출력
    print("Please enter your city")

city2 = "Seoul"
if city2:
    print("You are in:", city2)
else:
    # 출력
    print("Please enter your city")


# 논리연산자(중요)
# and, or, not
# 참고 : https://www.tutorialspoint.com/python/python_basic_operators.htm

a = 75
b = 40
c = 10

print('and : ', a > b and b > c)  # a > b > c
print('or : ', a > b or b > c)  # 실제로  앞에 참이면 뒤는 실행하지도 않는다.  인터프리터 엔진을 통해 효율성을 추구
print('not : ', not a > b)
print('not : ', not b > c)
print(not True)
print(not False)

# 산술, 관계, 논리 우선순위
# 산술 > 관계 > 논리 순서로 적용

print('e1 : ', 3 + 12 > 7 + 3)
print('e2 : ', 5 + 10 * 3 > 7 + 3 * 20)
print('e3 : ', 5 + 10 > 3 and 7 + 3 == 10)
print('e4 : ', 5 + 10 > 0 and not 7 + 3 == 10)

score1 = 90
score2 = 'A'

# 복수의 조건이 모두 참일 경우에 실행.
if score1 >= 90 and score2 == 'A':
    print("Pass.")
else:
    print("Fail.")

# 예제

id1 = "vip"
id2 = "admin"
grade = 'platinum'

if id1 == "vip" or id2 == "admin":
    print("관리자 인증")

if id2 == "admin" and grade == "platinum":
    print("최상위 관리자")


# 다중 조건문
num = 90

if num >= 90:
    print('Grade : A')
elif num >= 80:
    print('Grade : B')
elif num >= 70:
    print('Grade : C')
else:
    print('과락')

# 중첩 조건문

grade = 'A'
total = 95

if grade == 'A':
    if total >= 90:
        print("장학금 100%")
    elif total >= 80:
        print("장학금 80%")
    else:
        print("장학금 70%")
else:
    print("장학금 50%")

# in, not in

q = [10, 20, 30]
w = {70, 80, 90, 90}
e = {"name": 'Lee', "city": "Seoul", "grade": "A"}
r = (10, 12, 14)

print(15 in q)
print(90 in w)
print(12 not in r)
print("name" in e)  # key 검색
print("seoul" in e.values())  # value 검색

------------------------------------------


# 파이썬 반복문
# FOR 실습

#  for 문 구조
# for i in <collection>
#     <loop body>

# range 치면 code assistance에 start, stop, step 정보가 보임
for v1 in range(10):  #  0~9  9 까지 표현
    print("v1 is :", v1)

print()

for v2 in range(1, 11):  # 1 ~10
    print("v2 is :", v2)

print()

for v3 in range(1, 11, 2):   # 1 ~ 10 , 2 step
    print("v3 is :", v3)

print()

# 1 ~ 1000합

sum1 = 0

for v in range(1, 1001):
    sum1 += v    # sum1 = v + 1

print('1 ~ 1000 Sum : ', sum1)   # print 가 선언된 위치 확인


print('1 ~ 1000 Sum : ', sum(range(1, 1001)))  # range함수를 통해 generator 해서 리스트형태로 구성후 sum 함수 사용
#print(type(range(1,11)))
#print(list(range(1,11)))

print('1 ~ 1000 안에 4의 배수의 합 : ', sum(range(1, 1001, 4)))

 
# Iterables 자료형 반복  , 파이썬에서 Iterables 라고 하는것은 반복하는 객체를 의미
# 문자열, 리스트, 튜플, 집합, 사전
# iterable 리턴 함수 : range, reversed, enumerate, filter, map, zip

# 예제1
names = ["Kim", "Park", "Cho", "Lee", "Choi", "Yoo"]

for name in names:
    print("You are", name)

# 예제2
lotto_numbers = [11, 19, 21, 28, 36, 37]

for number in lotto_numbers:
    print("Current number : ", number)

# 예제3
word = 'Beautiful'   # 문자열도 시퀀스 형이기 때문에 Iterable 하기 때문에 사용가능

for s in word:
    print('word : ', s)

# 예제4
my_info = {
    "name": "Lee",
    "Age": 33,
    "City": "Seoul"
}

for key in my_info:
    print(key, ":", key)

for key in my_info:
    print(key, ":", my_info.[key])

for key in my_info:
    print(key, ":", my_info.get(key))


for val in my_info.values():
    print(val)

# 예제5
name = 'FineApplE'

for n in name:
    if n.isupper():    # isupper를 대문자인지를 체크 islower는 소문자인지 체크
        print(n)    #맞으면 그냥 대문자 출력
    else:    #아니면
        print(n.upper())    #소문자를 대문자로 변경해서 출력

numbers = [14, 3, 4, 7, 10, 24, 17, 2, 33, 15, 34, 36, 38]

# break   for 문 탈출 
for num in numbers:
    if num == 34:
        print("Found : 34!")
        break
    else:
        print("Not found : ", num)

# continue  을 만나면  조건 부분으로 넘어감    
# bool 불린형을 처리하고 싶지 않을때 이용

lt = ["1", 2, 5, True, 4.3, complex(4)]

for v in lt:
    if type(v) is bool:    # is 는 자료 형을 비교할 때 사용  is not , is
        continue

    print("current type : ", type(v))
    print("multiply by 2:", v * 3)

# for ~ else 구문   파이썬에서 지원하는 특이한 구문
numbers = [14, 3, 4, 7, 10, 24, 17, 2, 33, 15, 34, 36, 38]

for num in numbers:
    if num == 34:  # 45
        print("Found : 34!")
        break
else:
    print("Not Found 45...")


# 구구단 출력

for i in range(2, 10):
    for j in range(1, 10):
        print('{:4d}'.format(i * j), end='')  # 간격4를 주고 format 함수가 처리한 정수를 우측부터 출력 그리고end 옵션을
						 # 통해 이어서 출력	
    print()


# 변환 예제
name = 'Aceman'
print('Reversed : ', reversed(name))
print('List : ', list(reversed(name)))
print('Tuple : ', tuple(reversed(name)))
print('Set : ', set(reversed(name)))  # 순서X

# 파이썬 반복문   for 보다는 if과 가깝다.
# While 실습  

# while <expr>:      #expression   표현식
#    <statement(s)>   #코드

# 예제1
n = 5
while n > 0:
    print(n)
    n = n - 1   # n -= 1
#    print(n) 를 아래에 두면? 
    
# 예제2
a = ['foo', 'bar', 'baz']

while a:
    print(a.pop())
#    print(a) 만약  이렇게 출력 하면 위험한 코드가 된다. 이유는?     a = ['foo', 'bar', 'baz']   ==  True 측  while True:  로 무한하게 반복된다.  pop 함수를 사용하지 않으면 문제가 될 수 있다.

# if 중첩
# 예제3
# break , continue

n = 5
while n > 0:
    n -= 1
    if n == 2:
        break
    print(n)
print('Loop Ended.')  
print()

# 예제4
m = 5
while m > 0:
    m -= 1
    if m == 2:
        continue
    print(m)
print('Loop Ended.')   

# 예제5
i = 1

while i <= 10:
    print('i:',i)
    if i == 6:
        break
    i += 1


# While - else 구문

# 예제6
n = 10
while n > 0:
    n -= 1
    print(n)
    if n == 5:
        break
else:
    print('else out.')

# 예제7 
a = ['foo', 'bar', 'baz', 'qux']
s = 'qux'

i = 0

while i < len(a):
    if a[i] == s:
        break
    i += 1
else:
    print(s, 'not found in list.')
    
    
# 무한반복
# while True:
#     print('Foo')

# 예제8
a = ['foo', 'bar', 'baz']
while True:
    if not a:
        break
    print(a.pop())


 ==== while 실습 ====

변수명 num으로 지정하고

최대 100까지 증가

55 일 경우에만 '일치' 가 출력되고 

나머지는 '불일치'가 불일치가 출력되도록 코딩해보시오.

(5씩 증가하도록 하시오.)

num =0
while num <= 100:
	if num==55:
		print("{} : 일치".format(num))
	else:
		print("{} : 불일치".format(num))
	num=num+5

# 파이썬 함수 및 중요성
# 코드의 복잡도가 증가하는 추세. 
# 함수의 필요성 1. 단계별로 프로그램을 작성할 필요존재.  2. 코드의 재 사용성을 높일 필요 있음(동일한 기능 한번에 수정 가능).  3. 코드의 안정성을 높일 수 있다.
# 파이썬 함수식 및 람다(lambda)

# 함수 정의 방법
# def function_name(parameter):    
#     code

# 예제1
def first_func(w1):    # w1 인수 를 매개변수라고 한다.
    print("Hello, ", w1)

word = "Goodboy"

#firstfunc()      # 이렇게 선언하면 에러가 발생. 이유는  함수 자체에서 매개변수를 원하는데 입력 하지 않아서.
first_func(word)
#firstfunc      # 이렇게 선언하면   
#print(firstfunc)  #했을때  함수가 id   객체이기 때문에  (오프젝트이기 때문에)  fistfunc()로 선언해야 한다.


# 예제2
def return_func(w1):
    value = "Hello, " + str(w1)
    return value           
#	    return "Hello, " + str(w1)    # 이 방법이 깔끔함

x = return_func('Goodboy2')
print(x)
    
#return이 있는 함수는 결과값으로 반환되는 값을 받을 변수를 선언해야 함
# 예제 1과 예제 2를 비교하면 예 

#함수형 프로그램 이란  우리가 수업 시간에 이용했던   reversed() 이런 건 함수 형태를 이용한 것 
#파이썬은 함수형 프로그램   그리고 함수형 프로그래밍 이라는 방법이라는 기법이 존재함
#효과적인 코딩을 위해서 함수를 학습할 필요가 존재

# 프로그래머로 취업시  질문이 명령형 프로그래밍과 함수형 프로그래밍의 차이와 작성법을 묻는 경우가 많음

# 예제3(다중반환)

def func_mul(x):
    y1 = x * 10
    y2 = x * 20
    y3 = x * 30
    return y1, y2, y3    # 다운 리턴  

x, y, z = func_mul(10)   #  이것이 언패킹 

print(x, y ,z)

# 튜플 리턴
def func_mul2(x):
    y1 = x * 10
    y2 = x * 20
    y3 = x * 30
    return (y1, y2, y3)      # 튜플로 패킹해서 묶어주면 

q = func_mul2(20)

print(type(q), q, list(q))     # 튜플로 패킹해서 묶어진채로 출력

# 리스트 리턴
def func_mul2(x):
    y1 = x * 10
    y2 = x * 20
    y3 = x * 30
    return [y1, y2, y3]     # 리스트로 묶어줌


p = func_mul2(30)

print(type(p), p, set(q))    # 집합으로 출력도 가능

# 딕셔너리 리턴
def func_mul3(x):
    y1 = x * 10
    y2 = x * 20
    y3 = x * 30
    return {'v1': y1, 'v2': y2, 'v3': y3}


d = func_mul3(30)

#print(type(d), d)
print(type(d), d, d.get('v2'), d.items(), d.keys())
#print(d.values())


# 중요
# *args, **kwargs

# *args(언팩킹)     가변적인 매개변수( 갯수가 다양할 경우)를 처리 함. 보통 자료형 중 튜플 형태 처리 할 때 많이 함
def args_func(*args): # 매개변수 명 자유 *a 로 써도 됨
    for i, v in enumerate(args):       # i 는 0 번 부터 시작하는 index , v 는 실제 value 값
						# enumerate 함수가 만들어줌  즉 튜플 형태의 값 생성
        print('Result : {}'.format(i), v)
    print('-----')

args_func('Lee')     # 여기서 중요한건 def args_func(*args) 정의 시  def args_func(args) 로 선언하면 lee를 문자로 받아서
				문자 하나하나를 읽어들여서 처리
			# 하지만 def args_func(*args)로 선언하면 튜플 형태의 0 번 index로 처리됨

args_func('Lee', 'Park')     #  여기는 인자가 2개 이기 때문에 그전에 함수정의에서는 
				#  함수 정의 시 def args_func(args, args, args):  인자의 갯수 만큼 선언해야 하지만 
				     현재 *args 로 처리 함으로써 해결
args_func('Lee', 'Park', 'Kim')  # 튜플형태의 값을    *args   가변인자 값을 처리 하여 언패킹 하는 형태로 이해


# **kwargs(언팩킹)    - 딕셔너리 자료형 언패킹은  ** 를 선언해서 사용함

def kwargs_func(**kwargs): # 매개변수 명 자유
    for v in kwargs.keys():
        print("{}".format(v), kwargs[v])
    print('-----')

kwargs_func(name1='Lee')
kwargs_func(name1='Lee', name2='Park')
kwargs_func(name1='Lee', name2='Park', name3='Cho')



# 전체 혼합
def example(args_1, args_2, *args, **kwargs):  # 인수, 인수, 튜플, 딕셔너리
    print(args_1, args_2, args, kwargs)

example(10, 20, 'Lee', 'Kim', 'Park', 'Cho', age1=20, age2=30, age3=40)
			# 정말 매력적인 파이썬 처리 부분  인수의 갯수에 제한받지않고 사용

# 중첩함수      클로저. 지역변수의 상태 유지를 이해 할 필요

def nested_func(num):
    def func_in_func(num):  
        print(num)   
    print("In func")
    func_in_func(num + 100)

nested_func(100)

# 실행불가
# func_in_func(1000)      # 함수 안에 정의된 함수를 호출하면 "not defined" 로 정의되지 않았다는 에러가 발생
# 정의되는 시점은  즉 메모리에 올라가서 사용될 수 있게 되는 시점은 nested_func 정의되고  호출 되었을때 기 때문
# 이걸 부모함수 자식 함수로 설명하면  부모함수자 정의되고 실행 되지 않았기 때문에 자식함수를 호출 할 수 없음


# 람다식 예제
# 메모리 절약, 가독성 향상, 코드 간결
# 함수는 객체 생성 -> 리소스(메모리) 할당
# 람다는 즉시 실행 함수(Heap 초기화) -> 메모리 초기화
# 남발 시 가독성 오히려 감소

#def mul_func(x, y):
#    return x * y
    
#lambda x, y:x*y

# 일반적함수 -> 할당
def mul_func(x, y):
    return x * y

#x = mul_func(4,5)
#print(x)
print(mul_func(10, 50))

mul_func_var = mul_func     # 이름이 있기 때문에 객체가 만들어지고 메모리에 할당됨 
print(mul_func_var(20,50))

# 람다 함수 -> 할당
lambda_mul_func = lambda x,y:x*y   # 객체 이름이 정의 되지 않았지만 lambda 함수가 인수를 받아 처리
print(lambda_mul_func(50,50))


 
def func_final(x, y, func):
    print('>>>>', x * y * func(100, 100))

func_final(10, 20, lambda_mul_func)

func_final(10,20, lambda x,y:x*y)        # 즉시 lambda 로 정의해서 사용
#func_final(10, 20, lambda_mul_func)   # 자주 사용하는 함수를 lambda 로 정의 해두고 사용
#func_final(10, 20, mul_func_var)        # 일반적인 함수 정의 해서 사용
 

# Hint
def tot_length1(word: str, num: int) -> int:
    return len(word) * num


print('hint exam1 : ', tot_length1("i love you", 10))


def tot_length2(word: str, num: int) -> None:
    print('hint exam2 : ', len(word) * num)


tot_length2("niceman", 10)

------------------------------------------


# 파이썬 사용자 입력
# Input 사용법   버전 2.x 때에는 input_raw 같은 함수가 있었는데 저희는 3.x  버전이니까 input 사용
# 기본 타입(str)

# 예제1      터미널 환경에서 실행 .  인터프리터 언어의 특징
name = input("Enter Your Name : ")
grade = input("Enter Your Grade : ")
company = input("Enter Your Company name : ")

print(name, grade, company)

# 예제2
number = input("Enter number : ")
name = input("Enter name : ")

#print("type of number", type(number))
print("type of number", type(number), number * 3)    # 기본 타입(str)
print("type of nanme", type(name))

# 예제3(계산)
first_number = int(input("Enter number1 : "))
second_number = int(input("Enter number2 : "))

total = first_number + second_number
print("first_number + second_number : ", total)


# 예제4
float_number = float(input("Enter a float number : "))

print("input float : ", float_number)
#print("input float : ", float_number * 1.2113)     # 만약 형변환이 안되었다면 에러가 발생
print("input type : ", type(float_number))


# 예제5
print("FirstName - {0}, LastName - {1}".format(input("Enter first name : "), input("Enter second name : ")))
# input 함수는 변수로 할당 하지 않아도 필요한 부분에서 선언해서 함수의 안에서도 사용가능

# 파이썬 클래스
# OOP(Object-Oriented Programming객체 지향 프로그래밍), Self, 인스턴스 메소드, 인스턴스 변수
# c++, java, python, golang 등에서 객체 지향 지원
# 생상선 향상을 위해 존재.  위에서 내려오는 순서대로 처리 하는 절차지향에 비해 장점 존재
# 객체화 시키고 재사용을 극대화 시키고 상속을 통해 코드 재사용이 용이
# 코드 재사용을 통해 코드개선 수정, 버그 개선을 통한 유지보수가 용이


# 클래스 and 인스턴스 차이 이해
# 네임스페이스 : 객체를 인스턴스화 할 때 저장된 공간
# 클래스 변수 : 직접 접근 가능, 공유
# 인스턴스 변수 : 객체마다 별도 존재

# 예제1    
#애견병원  소프트웨어를 개발한다는 가정하에 
#  진돗개 = 
# 리트리버 =   형태로 변수를 선언하고 만들 수 있지만  종이 수백 종이 되고 견종의 이름이 바뀔때 마다 
# 선언하게 된다면 코드의 양도 늘어나고 가독성이 떨어짐
# 물론 우리가 배운  함수를 이용해서  모듈화를 잘하면  좀더 단순하게 구성 할 수 있지만 
# 클래스는 이러한 상황일때 사용하는 것
class Dog: 
	pass

class Dog(): 
	pass

class Dog(object):   # object 상속 이기 때문에  3가지 모두 선언할 수 있다.
	pass




class Dog: # object 상속
    # 클래스 속성
    species = 'firstdog'     # 클래스 변수
    
    # 초기화/인스턴스 속성    모든 클래스는 초기화 /인스턴스 속성을 가진다.    java에서는 생성자가 있다.
    def __init__(self, name, age):   # __init__ 메소드가 호출 되고 (self
        self.name = name
        self.age = age
# 여기 까지 작성하고 실행 시 에러가 없다면 Dog 라는 클래스 만듬
# 개를 통합 하는 객체이고 우리가 만들 소프트웨어의 구현할 대상을 객체라고 함
# 즉 클래스는 틀이고  인스턴스화가 필요

#인스턴스는 틀을 가지고 찍어내는 객체를 의미
# 인스턴스는 코드로 구현해서 메모리에 올라가 변수를 활용 할 수 있는 대상

        
# 클래스 정보
print(Dog)

# 인스턴스화
a = Dog("mikky", 2)      #인스턴스 변수 
b = Dog("baby", 3)
#c = Dog("mikky", 2)

# 비교
print(a == b)
print(a == b, id(a), id(b))
print(a == b, id(a), id(b), id(c))   # 인스턴스화 시킨것은 모두 id가 다르다.


# 네임스페이스  # 네임스페이스 : 객체를 인스턴스화 할 때 저장된 공간  - 딕셔너리 형태
print('dog1', a.__dict__)   #__dict__ 을 선언하면 클래스가 가지고 있는 attribute 속성 값을 확인 할 수 있음
print('dog2', b.__dict__)     
    
# 인스턴스 속성 확인
print('{} is {} and {} is {}'.format(a.name, a.age, b.name, b.age))

if a.species == 'firstdog':
    print('{0} is a {1}'.format(a.name, a.species))

print(Dog.species)  # 클래스로 바로 접근하여 변수를 물어보는거 가능
print(a.species)    # 인스턴스화 된 변수로도 접근 가능
print(b.species)

# 예제2
# self의 이해   .  self가 붙으면 나만의 인스턴스 attribute 속성
class SelfTest:
    def func1():   # 메소드 두개 생성
        print('Func1 called')
    def func2(self):    # 메소드 두개 생성
        print('Func2 called')
#  위에서는 __init__ 메소드를 선언했는데 여기서 선언하지 않은 것은  def __init__(self, name, age): 
#  파이썬이 클래스를 만들때 내부적으로 실행함. 여기서 name, age 같은걸 따로 정의 하지 않을 거기 때문에
# __init__ 메소드를 선언 하지 않음


f = SelfTest()    # 인스턴스화

# print(dir(f))    # 끝에 가면 클래정의한  함수 두개가 나옴
print(id(f))
# f.func1() # 예외   원래 func1은 매개변수가 없는데 뭔가 하나가 넘어왔다.라는 뜻  f 가 넘어 왔는데 
	 	 # 매개변수가 없어서 처리가 안됨 
f.func2()  # func2가 처리됨

"""
class SelfTest:
    def func1():   # 클래스내부에 매개변수를 선언하는데 self가 없으면 이걸 우리는 클래스메소드라한다.
        print('Func1 called')
    def func2(self):    # 메소드 두개 생성   self 는 인스턴스를 요구한다. 즉 , f = SelfTest()  인스턴스화 한 f 를 받아온다
        print(id(self))   # 즉 다음과 같이 self 의 id 를 호출 하면  f 의 id 값을 받아오는 것을 확인 할 수 있다.
        print('Func2 called')
"""

SelfTest.func1()   # 클래스를 통해 메소드 접근
# SelfTest.func2() # 예외  이유는 self가 존재하기 때문에 인스턴스를 필요로함 즉 아래와 같이 f 를 선언해주면 됨
SelfTest.func2(f)   

# 예제3
# 클래스 변수, 인스턴스 변수
class Warehouse:     # 창고
    # 클래스 변수 
    stock_num = 0 # 재고
    
    def __init__(self, name):
        # 인스턴스 변수
        self.name = name
        Warehouse.stock_num += 1
    
    def __del__(self):    # 객체가 소멸할때 호출 되는 함수  __del__
        Warehouse.stock_num -= 1

user1 = Warehouse('Lee')    # 인스턴스화 
user2 = Warehouse('Cho')

print(Warehouse.stock_num)     # 인스턴스화 한 

# Warehouse.stock_num = 0.0094

print(user1.name)
print(user2.name)
print(user1.__dict__)
print(user2.__dict__)  # stock_num 이 user1,2 의 네임 스페이스에는 정보가 보이지 않지만
print('before', Warehouse.__dict__)  # 클래스의 네임스페이스에  stock_num 이 있기 때문에
print('>>>', user1.stock_num)    # 여기서 클래스의 네임스페이스에서 공유받아서 출력 해줌
#Warehouse.stock_num = 50 으로 수정하면 값이 변경됨   좋은 방법은 아님

del user1
print('after', Warehouse.__dict__)

# 예제4
class Dog: # object 상속
    # 클래스 속성
    species = 'firstdog'
    
    # 초기화/인스턴스 속성
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def info(self):
        return '{} is {} years old'.format(self.name, self.age)
        
    def speak(self, sound):
        return "{} says {}!".format(self.name, sound)


# 인스턴스 생성
c = Dog('july', 4)
d = Dog('Marry', 10)
# 메소드 호출
print(c.info())
print(d.info())
# 메소드 호출
print(c.speak('Wal Wal'))
print(d.speak('Mung Mung'))

# 파이썬 내장(Built-in) 함수
# 자주 사용하는 함수 위주로 실습
# 사용하다보면 자연스럽게 숙달
# str(), int(), tuple() 형변환 이미 학습

# 절대값
# abs()

print(abs(-3))

# all, any : iterable 요소 검사(참, 거짓)
print(all([1,2,3])) # and
print(any([1,2,0])) # or

# chr : 아스키 -> 문자 , ord : 문자 -> 아스키

print(chr(67))
print(ord('C'))

# enumerate : 인덱스 + Iterable 객체 생성
for i, name in enumerate(['abc', 'bcd', 'efg']):
    print(i, name)


#  filter : 반복가능한 객체 요소를 지정한 함수 조건에 맞는 값 추출

def conv_pos(x):
    return abs(x) > 2
    
print(list(filter(conv_pos, [1, -3, 2, 0, -5, 6])))
print(list(filter(lambda x: abs(x) > 2, [1, -3, 2, 0, -5, 6])))

# id : 객체의 주소값(레퍼런스) 반환

print(id(int(5)))
print(id(4))

# len : 요소의 길이 반환
print(len('abcdefg'))
print(len([1,2,3,4,5,6,7]))

# max, min : 최대값, 최소값

print(max([1,2,3]))
print(max('python study'))
print(min([1,2,3]))
print(min('python study'))

# map : 반복가능한 객체 요소를 지정한 함수 실행 후 추출
def conv_abs(x):
    return abs(x)
    
print(list(map(conv_abs,[1,-3,2,0,-5,6])))
print(list(map(lambda x:abs(x),[1,-3,2,0,-5,6])))

# pow : 제곱값 반환
print(pow(2,10))

# range : 반복가능한 객체(Iterable) 반환
print(range(1,10,2))
print(list(range(1,10,2)))
print(list(range(0,-15,-1)))

# round : 반올림

print(round(6.5781, 2))
print(round(5.6))

# sorted : 반복가능한 객체(Iterable) 정렬 후 반환 

print(sorted([6,7,4,3,1,2]))
a = sorted([6,7,4,3,1,2])
print(a)
print(sorted(['p','y','t','h','o','n']))


# sum : 반복가능한 객체(Iterable) 합 반환
print(sum([6,7,8,9,10]))
print(sum(range(1,101)))

# type : 자료형 확인

print(type(3))
print(type({}))
print(type(()))
print(type([]))

# zip : 반복가능한 객체(Iterable)의 요소를 묶어서 반환

print(list(zip([10,20,30],[40,50,777])))
print(type(list(zip([10,20,30],[40,50,777]))[0]))

# 파이썬 외장(External)함수
# 실제 프로그램 개발 중 자주 사용
# 종류 : sys, pickle, os, shutil, glob, temfile, time, random 등

# sys : 실행 관련 제어
import sys

# 예제1
print(sys.argv)

# 예제2(강제 종료)
# sys.exit() 

# 예제3(파이썬 패키지 위치)
print(sys.path)


# pickle : 객체 파일 쓰기
import pickle

# 예제4(쓰기)
f = open("test.obj", 'wb')
obj = {1: 'python', 2: 'study', 3: 'basic'}
pickle.dump(obj, f)
f.close()

# 예제5(읽기)
f = open("test.obj", 'rb')
data = pickle.load(f)
print(data)
f.close()


# os : 환경 변수, 디렉토리(파일) 처리 관련, 운영체제 작업 관련
# mkdir, rmdir(비어있으면 삭제), rename
import os

# 예제6
print(os.environ)
print(os.environ['USERNAME'])

# 예제7(현재 경로)
print(os.getcwd())


# time : 시간 관련 처리
import time

# 예제8
print(time.time())

# 예제9(형태 변환)
print(time.localtime(time.time()))

# 예제10(간단 표현)
print(time.ctime())

# 예제11(형식 표현)
print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))

# 예제12(시간 간격 발생)
for i in range(5):
	print(i)
	time.sleep(1)


# random : 난수 리턴
import random

# 예제13
print(random.random())

# 예제14
print(random.randint(1, 45))

# 예제15(섞기)
d = [1, 2, 3, 4, 5]
random.shuffle(d)
print(d)

# 예제16(무작위 선택)
c = random.choice(d)
print(c)


# webbrowser : 본인 OS 의 웹 브라우저 실행

# 예제17
webbrowser.open("http://google.com")

# 예제18(새창 실행)
webbrowser.open_new("http://google.com")

# 파일 읽기 및 쓰기

# 읽기 모드 : r, 쓰기모드 w, 추가 모드 a, 텍스트 모드 t, 바이너리 모드 b
# 상대 경로('../, ./'), 절대 경로('C:\Django\example..')

# 파일 읽기(Read)
# 예제1

f = open('./resource/it_news.txt', 'r', encoding='UTF-8')
# 속성 확인
print(dir(f))
# 인코딩 확인
print(f.encoding)
# 파일 이름
print(f.name)
# 모드 확인
print(f.mode)
cts = f.read()
print(cts)
# 반드시 close
f.close()

# 예제2
with open('./resource/it_news.txt', 'r', encoding='UTF-8') as f:
    c = f.read()
    print(c)
    print(iter(c))
    print(list(c))

print()

# 예제3
# read() : 전체 읽기 , read(10) : 10Byte

with open('./resource/it_news.txt', 'r', encoding='UTF-8') as f:
    c = f.read(20)
    print(c)
    c = f.read(20)
    print(c)
    c = f.read(20)
    print(c)
    f.seek(0,0)
    c = f.read(20)
    print(c)

print()

# 예제4
# readline : 한 줄 씩 읽기

with open('./resource/it_news.txt', 'r', encoding='UTF-8') as f:
    line = f.readline()
    print(line)
    line = f.readline()
    print(line)


print()

# 예제5
# readlines : 전체를 읽은 후 라인 단위 리스트로 저장

with open('./resource/it_news.txt', 'r', encoding='UTF-8') as f:
    cts = f.readlines()
    print(cts)
    print()
    for c in cts:
        print(c, end='')
        
print()

# 파일 쓰기(write)

# 예제1
with open('./resource/contents1.txt', 'w') as f:
    f.write('I love python\n')

# 예제2
with open('./resource/contents1.txt', 'a') as f:
    f.write('I love python2\n')
    
    
# 예제3
# writelines : 리스트 -> 파일
with open('./resource/contents2.txt', 'w') as f:
    list = ['Orange\n', 'Apple\n', 'Banana\n', 'Melon\n']
    f.writelines(list)
    
# 예제4
with open('./resource/contents3.txt', 'w') as f:
    print('Test Text Write!', file=f)
    print('Test Text Write!', file=f)
    print('Test Text Write!', file=f)



# CSV 파일 읽기 및 쓰기

# CSV : MIME - text/csv

import csv

# 예제1
with open('./resource/test1.csv', 'r') as f:
    reader = csv.reader(f)
    # next(reader) Header Skip
    # 객체 확인
    print(reader)
    # 타입 확인
    print(type(reader))
    # 속성 확인
    print(dir(reader))  # __iter__
    print()

    for c in reader:
        # print(c)
        # 타입 확인
        print(type(c))
        # list to str
        print(''.join(c))

# 예제2
with open('./resource/test2.csv', 'r') as f:
    reader = csv.reader(f, delimiter='|')  # 구분자 선택
    # next(reader) Header 스킵
    # 확인

    for c in reader:
        # print(c)
        print(''.join(c))

# # 예제3 (Dict 변환)
with open('./resource/test1.csv', 'r') as f:
    reader = csv.DictReader(f)
    # 확인
    print(reader)
    print(type(reader))
    print(dir(reader))  # __iter__ 확인
    print()

    for c in reader:
        for k, v in c.items():
            print(k, v)
        print('-----')

# 예제4
w = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]]

with open('./resource/write1.csv', 'w', encoding='utf-8') as f:
    print(dir(csv))
    wt = csv.writer(f)
    # dir 확인
    print(dir(wt))
    # 타입 확인
    print(type(wt))
    for v in w:
        wt.writerow(v)

# 예제5
with open('./resource/write2.csv', 'w', newline='') as f:
    # 필드명
    fields = ['one', 'two', 'three']
    # Dict Writer 선언
    wt = csv.DictWriter(f, fieldnames=fields)
    # Herder Write
    wt.writeheader()

    for v in w:
        wt.writerow({'one': v[0], 'two': v[1], 'three': v[2]})

